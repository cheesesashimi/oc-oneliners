#!/usr/bin/env python3

from dataclasses import dataclass
from collections import defaultdict

import datetime
import os
import subprocess


# Represents an individual template file in the MCO repository.
@dataclass
class TemplateFile:
    filename: str
    is_owned: bool
    contributors: list

    @classmethod
    def FromFilename(cls, filename, is_owned):
        cmd = subprocess.run(
            ["git", "blame", "-p", "--show-email", filename],
            capture_output=True,
            text=True,
            check=True,
        )

        emails = defaultdict(int)

        mail_keys = ["author-mail", "committer-mail"]

        for record in parse_git_blame_data(cmd.stdout.splitlines()):
            for key in mail_keys:
                emails[record[key]] += 1

        # Convert into a tuple so that the number of emails can be counted and
        # sorted in descending order.
        emails = sorted(
            [(email, count) for email, count in emails.items()],
            key=lambda x: x[1],
            reverse=True,
        )

        return TemplateFile(filename=filename, is_owned=is_owned, contributors=emails)


# Generated by Google Gemini
def parse_git_blame_data(lines):
    blame_data = []
    commits = {}  # Cache for commit metadata

    i = 0
    while i < len(lines):
        line = lines[i]
        parts = line.split()

        # 1. Parse the Header Line
        # Format: <sha> <orig_lineno> <final_lineno> <group_lines>
        sha = parts[0]
        orig_lineno = parts[1]
        final_lineno = parts[2]

        # 2. Parse Commit Metadata (if not already cached)
        if sha not in commits:
            commits[sha] = {}
            i += 1
            while i < len(lines) and not lines[i].startswith("\t"):
                # Split metadata into key and value (e.g., "author Linus Torvalds")
                meta_parts = lines[i].split(" ", 1)
                if len(meta_parts) == 2:
                    commits[sha][meta_parts[0]] = meta_parts[1]
                i += 1
        else:
            # Skip metadata if we already have it for this SHA
            while i < len(lines) and not lines[i].startswith("\t"):
                i += 1

        # 3. Parse the Content Line
        # The line itself starts with a tab
        content = lines[i][1:] if i < len(lines) else ""

        keys = [
            "sha",
            "author",
            "committer",
            "author-mail",
            "committer-mail",
        ]

        time_keys = [
            "author-time",
            "committer-time",
        ]

        record = {}
        for key in keys + time_keys:
            record[key] = commits[sha].get(key)

        for key in time_keys:
            if record[key] == "":
                record[key] = None
            else:
                record[key] = datetime.datetime.fromtimestamp(int(record[key]))

        blame_data.append(record)

        i += 1

    return blame_data


def identify_owned_and_unowned_files():
    all_files = set()
    owners_files = set()

    # First, enumerate all files within the templates directory and identify
    # any OWNERS files specifically.
    for root, dirs, files in os.walk("./templates"):
        for file in files:
            full_path = os.path.join(root, file)
            all_files.add(full_path)
            if file == "OWNERS":
                owners_files.add(full_path)

    owned_files = set()

    # Next, strip the directory off of each OWNERS file and then walk that
    # directory structure to identify all files contained within. These files
    # have an owner according to the specification for OWNERS files here:
    # https://github.com/kubernetes/community/blob/master/contributors/guide/owners.md
    for owners_file in owners_files:
        subdir = os.path.dirname(owners_file)
        for root, dirs, files in os.walk(subdir):
            for file in files:
                full_path = os.path.join(root, file)
                if full_path not in owners_files:
                    owned_files.add(os.path.join(root, file))

    # Now we can determine which files are unowned because they are not
    # included in the set of either all files or the owners files.
    unowned_files = all_files - owned_files - owners_files

    # Load everything into a sorted list as a TemplateFile instance.
    owned_files = sorted(
        [TemplateFile.FromFilename(filename, True) for filename in owned_files],
        key=lambda x: x.filename,
    )

    unowned_files = sorted(
        [TemplateFile.FromFilename(filename, False) for filename in unowned_files],
        key=lambda x: x.filename,
    )

    return owned_files, unowned_files


owned_files, unowned_files = identify_owned_and_unowned_files()
for file in unowned_files:
    print(file.filename, "=>", file.contributors)
